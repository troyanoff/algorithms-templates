# 79090018
def search_target(nums, target, left, right):
    """Ищет элемент в сломанном массиве без повторов.
    
    Принимает на вход массив, искомый элемент(ИЭ), значения левого и правого
    индекса. Определяет месторасположение(индекс) ИЭ в массиве по логике 
    бинарного поиска, с вынужденным определением "сломанной" стороны массива. 
    """
    # Проверяем пока длинна массива больше 0.
    while right >= left:
        # Определяем середину.
        mid = (right + left) // 2
        # Сразу достаем значения.
        num_mid = nums[mid]
        num_right = nums[right]
        num_left = nums[left]
        # Сравниваем значения не только середины для экономии времени с ИЭ.
        if num_mid == target:
            return mid
        elif num_left == target:
            return left
        elif num_right == target:
            return right
        # После чего определяем в какую сторону идти. Сломан ли правый массив?
        elif num_mid > num_right:
            # Если сломан правый, проверяем значение в левом, так удобнее.
            if  num_left < target < num_mid:
                right = mid -1
            # Если не в левом, то остается только правый.
            else:
                left = mid + 1
        else:
            # Если правый не сломан, проверяем наличие ИЭ в правом массиве.
            if num_mid < target < num_right:
                left = mid + 1
            else:
                # Получается левый.
                right = mid - 1
    # Если весь массив проверен, возвращаем сигнал отсутстия ИЭ в массиве.
    return -1

def broken_search(nums, target) -> int:
    """Филигранно определяет длинну массива."""
    # Предоставленная сигнатура не предполагает передачу длинны массива,
    # хотя на ввод предполагается ее подача.
    # Поэтому находим длинну массива для объявления правого эл-та.
    len_nums = len(nums)
    left = 0
    right = len_nums - 1
    # Передаем в рекурсивную вспомогательную функцию поиска
    # и выводим ее результат.
    return search_target(nums, target, left, right)
